" -------- "
" Settings "
" -------- "

set backupskip=
set lazyredraw
set hidden
set kp=
set nostartofline
set laststatus=2
set noswapfile
set complete=.,w
set notimeout
set ttimeout

if version >= 700
    set statusline=%{expand('%:p:h')}/%#hcsSLFileName#%t%##\ %h%m\ %L\ %=%#hcsSLBufferNumber#%n%##\ %#hcsSLWindowNumber#%{winnr()}%##%#hcsSLFileName#%##\ %#hcsSLFileLineNumber#%l%#hcsSLLineColNumber#\ %v
endif

let g:is_bash = 1

" -------- "
" Mappings "
" -------- "

noremap ,<cr> :%s/<c-v><cr>/<cr>
noremap <s-PageUp> <c-w><up>
noremap <s-PageDown> <c-w><down>
noremap ,vm :so $MYVIMRC<cr>
imap <c-space> <space><space><space><space>
vnoremap ,cw :<c-u>%s/<c-r>*/<c-r>*/g<left><left>
noremap ,c*w :*s/\<<c-r>=expand("<cword>")<cr>\>/<c-r>=expand("<cword>")<cr>/g<left><left>
cnoremap <c-s> \_s\+
noremap <c-w>O :WinFullScreen<cr>
noremap <c-w>o :ZoomWin<cr>
noremap ,m `m
noremap ,cl :set cul!<cr>
noremap ,cc :set cuc!<cr>
noremap ,cb :set cuc! cul!<cr>
noremap <F11> mkHmlggg?G`lzt`k

noremap ,d "+d
noremap ,y "+y
noremap ,p "+p
noremap ,P "+P
noremap ,gp "+gp
noremap ,gP "+gP
noremap ,,d "*d
noremap ,,y "*y
noremap ,,p "*p
noremap ,,P "*P
noremap ,,gp "*gp
noremap ,,gP "*gP
noremap ,<space> :%s/ \+$/<cr>
nnoremap <up> g<up>
nnoremap <down> g<down>
nnoremap <c-j> <c-e>
nnoremap <c-k> <c-y>

nnoremap ,*    :set hls<cr>:let @/="\\<<c-r><c-w>\\>"<cr>
vnoremap ,*    :<del><del><del><del><del>set hls<cr>:let @/="\\<<c-r>*\\>"<cr>
nnoremap ,,*   :set hls<cr>:let @/="\\c<c-r><c-w>"<cr>
vnoremap ,,*   :<del><del><del><del><del>set hls<cr>:let @/="\\c<c-r>*"<cr>
nnoremap ,v*   :set hls<cr>:let @/="<c-r><c-w>"<cr>:vim '<c-r>/'
vnoremap ,v*   :<del><del><del><del><del>set hls<cr>:let @/="<c-r>*"<cr>:vim '<c-r>*'
nnoremap ,vw*  :set hls<cr>:let @/="<c-r><c-w>"<cr>:vim '\<<c-r>/\>'
nnoremap ,hw   :execute ":help " . expand("<cword>")<cr>

" -------------------------- "
" Invoking external programs "
" -------------------------- "

command! FollowLink call FollowLink()
function! FollowLink ()
  let line = getline (".")
  let line = matchstr (line, '\%(http://\|https://\|www\.\)[^ ,;\t]*')
  let line = substitute(line, '#', '\\#', 'g')
  exec "!/a/cp/bash/bin/FOLLOW_LINK '".line. "'"
endfunction
map <Leader>w :call FollowLink()<CR>

command! Krusader silent !krusader --left . &
command! Konsole silent !konsole &

" --------- "
" Underline "
" --------- "

" Underline:
"   Underlines the current line with the given character.
" Example:
"   Type this line:
"       something
"   Type the following command while the cursor is on that line:
"       :call Underline('-')
"   Now the line has been underlined with '-':
"       something
"       ---------
function! Underline(ch)
   let len = strlen(substitute(getline("."), ".", "x", "g"))
   normal o
   call setline(".",repeat(a:ch, len))
endfunction

" ,<char><char> underlines the current line with <char>.
" <char> may be any of the followings: - = ^ " ' :
noremap ,-- :call Underline('-')<cr>
noremap ,== :call Underline('=')<cr>
noremap ,^^ :call Underline('^')<cr>
noremap ,"" :call Underline('"')<cr>
noremap ,'' :call Underline("'")<cr>
noremap ,:: :call Underline(":")<cr>

" --- "
" HCW "
" --- "

" HCW:
"   Sets the horizontal size of the Vim window so that it will be just enough
"   for `n` columns. If `n` is not given, the default value of 80 is used.
" Examples:
"   :HCW      " sets the number of columns to 80
"   :HCW 70   " sets the number of columns to 70
function! HCW(...)
    exec 'set columns=' . ((a:0 == 0 ? 80 : a:1) +
    \ (&number ? max([&numberwidth, len(line('$')) + 1]) : 0))
endfunction

command! -nargs=? HCW call HCW(<args>)

" -------------- "
" ViewOn/ViewOff "
" -------------- "

" ViewOn/ViewOff:
"   Turns on and off "view" mode in which the cursor is hidden. In "normal
"   viewmode", the up and down arrows will scroll the screen.
" Examples:
"   :ViewOn   " view mode on
"   :ViewOff  " view mode off
function! ViewOn()
    noremap <down> <c-e>
    noremap <up> <c-y>
    highlight Cursor gui=NONE guifg=NONE guibg=NONE
endfunction
function! ViewOff()
    unmap <down>
    unmap <up>
    highlight Cursor gui=NONE guifg=bg guibg=fg
endfunction

function! ViewOn2()
    highlight Cursor gui=NONE guifg=NONE guibg=NONE
endfunction
function! ViewOff2()
    highlight Cursor gui=NONE guifg=bg guibg=fg
endfunction

command! ViewOn2 call ViewOn2()
command! ViewOff2 call ViewOff2()
command! ViewOn call ViewOn()
command! ViewOff call ViewOff()

" ----- "
" HSave "
" ----- "

" Makes up a temporary file name and saves the file there.

command! HSave w! `mktemp -p ~/vim.tmp.XXXXXXXX`

" ------------ "
" BufferOpener "
" ------------ "

" Lists the buffers and opens the selected one.

noremap <a-2> :buffers<BAR>
           \ let i = input("Buffer number: ")<BAR>
           \ execute "buffer " . i<CR>
noremap ,bs :buffers<BAR>
           \ let i = input("Buffer number: ")<BAR>
           \ execute "buffer " . i<CR>

" ----- "
" nohls "
" ----- "

command! -range HNohls nohls
noremap ,ls  :HNohls<cr>
noremap <silent> <cr> :HNohls<cr>

" --------------------------- "
" Additions to the MRU plugin "
" --------------------------- "

function! HMEFunction(name,split)
    " name: name of a pattern to search
    " split: is the window needed to be split
    if a:split == 1
        split
    endif
    MRU
    if a:name != ''
        let @/ = a:name
        exec 'normal /'.a:name."\<cr>"
    endif
endfunction

command! -nargs=? MS call HMEFunction("<args>",1)
command! -nargs=? ME call HMEFunction("<args>",0)

let MRU_Max_Entries = 100

" ----------------------------- "
" Copying stuff to the keyboard "
" ----------------------------- "

command! FileNameToClipboard let @+=expand('%:p') | let @*=@+
command! PathToClipboard let @+=expand('%:p:h') | let @*=@+
command! PureFileNameToClipboard let @+=expand('%:t') | let @*=@+

" -------------------------------- "
" Executing Vim code in the buffer "
" -------------------------------- "

" ,vv - Executes the visual area
" ,vl - Executed the current line
function! HRunVisual(mode) range
    if a:mode=='n'
        exec "normal! gvy\"*"
    else
        exec "normal! \<esc>"
    endif
    @*
endfunction

vnoremap ,vv :call HRunVisual('v')<cr>
nnoremap ,vv :call HRunVisual('n')<cr>
noremap <silent> ,vl yy:@"<cr>

" ------------------------------- "
" Editing files in the quick list "
" ------------------------------- "

" Finds the given file and edits it.
"
" Place a list like this in your vimrc:
"     if version >= 700
"         let g:hcs_quickfilelist = [
"         \    [ 'vimrc',  $MYVIMRC],
"         \    [ 'email', '/home/me/docs/email.txt'],
"         \]
"     endif
" Examples:
"     :E vimrc
"     :Sp email
if version >= 700
function! E(f, edit)
    for item in g:hcs_quickfilelist
        if item[0] == a:f
            let f = item[1]
            break
        endif
    endfor
    if a:edit == 'edit'
        execute 'edit ' . f
    else
        execute 'split ' . f
    endif
endfunction

command! -nargs=1 E call E('<args>', 'edit')
command! -nargs=1 SP call E('<args>', 'split')
command! -nargs=1 Sp call E('<args>', 'split')
endif

" ------------------------------ "
"  Running a script if it exists "
" ------------------------------ "

function! HRunFileIfExists(file) "{{{
    if v:version>=700 && filereadable(a:file)
        exec "source ".a:file
    endif
endfunction

" ------------ "
" Backup files "
" ------------ "

if v:version >= 700
    " If I have a /a/_/folders/vim_backup directory, let that be the backup
    " directory; otherwise don't back up.
    " (Vim version earlier than 7.0 don't have the finddir function.)
    if finddir("/a/_/folders/vim_backup") != ""
        set bdir=/a/_/folders/vim_backup/
        set backup
    else
        set nobackup
    endif
endif

" We set the 'backupext' option to contain the current date and time, so that
" the name of the backup file will be the concatenation of the name of the
" normal file and the current date and time.
function! HRefreshBackup()
    execute ":set backupext=" . strftime(".%y%m%d_%H%M")
    " You may want to have %H%M%S instead of %H%M if you want to have the
    " possibility of having mltiple backups in a minute.
endfunction

au BufWritePre * call HRefreshBackup()

" ---------- "
" Navigation "
" ---------- "
"
function! NavNext()
    if s:navigation_type == 0
        echo "Error navigation"
        let s:navigation_type = 1
        noremap <F5>  :cprev<cr>
        noremap <F6>  :cnext<cr>
    elseif s:navigation_type == 1
        echo "Buffer navigation"
        let s:navigation_type = 2
        noremap <F5>  :bprev<cr>
        noremap <F6>  :bnext<cr>
    else
        echo "Argument navigation"
        let s:navigation_type = 0
        noremap <F5>    :prev<cr>
        noremap <F6>    :next<cr>
    endif
endfunction

" Set Error navigation
let s:navigation_type = 0
silent call NavNext()

noremap <c-F12> :call NavNext()<cr>
command! NavNext call NavNext()
command! NavNext2 call NavNext() | call NavNext()

noremap <F7> :prev<cr>
noremap <F8> :next<cr>
